Timer unit: 1e-06 s

Total time: 50.3465 s
File: <ipython-input-268-f65cc6abc10f>
Function: run_filter at line 1

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     1                                           def run_filter(data, betas, win_size=12, beta_const=False,
     2                                                          image_indepen_noise=False, gate=False):
     3                                               
     4         1          4.0      4.0      0.0      nx, ny, nz = data.shape
     5                                           
     6         1          2.0      2.0      0.0      half_win = win_size // 2
     7                                           
     8                                               # Apodisation cube for sub-images
     9         1        309.0    309.0      0.0      apod = do_apod3d(win_size, win_size, win_size)
    10                                               
    11         1          2.0      2.0      0.0      os_skip = win_size/4 # using sin^4 window
    12         1       3011.0   3011.0      0.0      gated_data= np.zeros(shape=(nx,ny,nz), dtype='float64') # scratch array
    13                                           
    14         1        117.0    117.0      0.0      print('Implementing noise gating...')
    15                                               
    16         1         14.0     14.0      0.0      strides_x = np.arange(half_win, nx-half_win, step=os_skip)
    17         1          8.0      8.0      0.0      strides_y = np.arange(half_win, ny-half_win, step=os_skip)
    18         1          4.0      4.0      0.0      strides_z = np.arange(half_win, nz-half_win, step=os_skip)
    19                                           
    20     84673     140173.0      1.7      0.3      for count, (i, j, k) in enumerate(product(strides_x, strides_y, strides_z)):
    21                                                   # define sub-image coordinates
    22     84672     346157.0      4.1      0.7          x = (int(i-half_win), int(i+half_win))
    23     84672     169083.0      2.0      0.3          y = (int(j-half_win), int(j+half_win))
    24     84672     162273.0      1.9      0.3          z = (int(k-half_win), int(k+half_win))
    25                                                   
    26     84672     106888.0      1.3      0.2          if y[1]> ny or x[1]>nx or z[1]>nz:
    27                                                       continue
    28                                                       
    29     84672     950431.0     11.2      1.9          sub_image = data[x[0]:x[1], y[0]:y[1], z[0]:z[1]] * apod
    30     84672   18461747.0    218.0     36.7          fourier_image = fftn(sub_image)
    31                                                   
    32     84672     339312.0      4.0      0.7          subImageCube = ImageCube(sub_image, fourier_image)
    33                                           
    34     84672      74339.0      0.9      0.1          if image_indepen_noise:
    35                                                       noise_profile = betas
    36                                                   else:
    37     84672      87641.0      1.0      0.2              im_clip = sub_image
    38     84672     702265.0      8.3      1.4              im_clip[im_clip <0] = 0
    39     84672    2655655.0     31.4      5.3              im_total = np.sum(np.sqrt(im_clip))
    40     84672     596284.0      7.0      1.2              noise_profile = betas*im_total
    41                                               
    42     84672      73082.0      0.9      0.1          if gate:
    43     84672    1993179.0     23.5      4.0              filt = subImageCube.gate_filter(noise_profile)
    44                                                   else:
    45                                                       filt = subImageCube.wiener_filter(noise_profile)
    46                                           
    47                                                   # Keeping core region of DFT when using varying beta
    48     84672      88036.0      1.0      0.2          if not beta_const and not gate:
    49                                                       core_cor = (half_win-1, half_win+2)
    50                                                       filt = cube_shift_roll(filt, half_win, half_win, half_win)
    51                                                       
    52                                                       filt[core_cor[0]:core_cor[1],
    53                                                            core_cor[0]:core_cor[1],
    54                                                            core_cor[0]:core_cor[1]] = 1  
    55                                                       
    56                                                       filt = cube_shift_roll(filt, half_win, half_win, half_win)
    57                                           
    58                                                  
    59     84672   21848617.0    258.0     43.4          inverse_ft = (ifftn(fourier_image*filt)*apod).real
    60     84672    1535398.0     18.1      3.0          gated_data[x[0]:x[1], y[0]:y[1], z[0]:z[1]] += inverse_ft
    61                                                   
    62                                           
    63                                               #correction factor for windowing
    64                                               #only applicable for sin^4 window
    65         1      12439.0  12439.0      0.0      gated_data/=(1.5)**3
    66                                               
    67                                               
    68         1          2.0      2.0      0.0      return gated_data